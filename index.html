<html lang="ja">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=PT+Sans&display=swap" rel="stylesheet">
    <style type="text/css">
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        html {
            display: table;
            background-color: black;
        }

        body {
            display: table-cell;
            text-align: center;
            vertical-align: middle;
            color: white;
            background-color: black;
            font-family: 'PT Sans', sans-serif;
        }
    </style><!-- fragment shader -->
    <script id="fs" type="x-shader/x-fragment">precision mediump float;
    precision highp float;
    uniform sampler2D texture;
    uniform float time;
    uniform vec2  mouse;
    uniform vec2  resolution;
    varying vec2 tCoord;

    const float PI=3.141592;

    mat2 rotate2d(float _angle){
        return mat2(cos(_angle),-sin(_angle),
                    sin(_angle),cos(_angle));
    }
    
    float rand(vec2 n) {
        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
    }
    
    float noise(vec2 p) {
        vec2 ip = floor(p);
        vec2 u = fract(p);
        u = u*u*(3.0-2.0*u);
    
        float res = mix(
            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
        return res*res;
    }
    
    const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);
    
    float fbm( in vec2 p ){
        float f = 0.0;
        f += 0.5000*noise( p ); p = m2*p*2.02;
        f += 0.2500*noise( p ); p = m2*p*2.03;
        f += 0.1250*noise( p ); p = m2*p*2.01;
        f += 0.0625*noise( p );
    
        return f/0.769;
    }
    
    float dwarp( in vec2 p ,float t) {
      vec2 q = vec2(fbm(p + vec2(0.0,0.0)))-t*0.15;
      vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2)));
      r+= t * 0.15;
      return clamp(fbm( p + 1.760*r ),0.0,1.0);
    }

    vec4 texColor(vec2 s){
        vec2 inv=(s+vec2(1.0))/2.0;
        inv.y=1.0-inv.y;
        return texture2D(texture,inv);
    }

    vec2 disp(vec2 p){
        vec2 res=vec2(-p.y,p.x);
        res*=dot(p,p)*2.0;
        return res;
    }
    vec3 hsb( in vec3 c ){
        vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                 6.0)-3.0)-1.0,
                         0.0,
                         1.0 );
        rgb = rgb*rgb*(3.0-2.0*rgb);
        return c.z * mix(vec3(1.0), rgb, c.y);
    }

    struct di{
        vec2 p;
        vec2 i;
    };

    di devision(in vec2 p){
        float dec=4.;
        vec2 res=fract(p*dec);
        vec2 ind=floor(p*dec)/dec;
        float pl=abs(floor(sin(time)))*.3;
        for(float i=0.;i<4.;i++){
            if(rand(ind+i)<.5){
                dec*=2.;
                res=fract(p*dec);
                ind=floor(p*dec)/dec;
            }else{
                break;
            }
        }
        return di(res,ind);
    }

    float circle(in vec2 p){
        p-=vec2(.5);
        return floor(4.*dot(p,p));
    }

    float cros(in vec2 p){
        p-=vec2(.5);
        float r=(abs(p.x)<.15)||(abs(p.y)<.15)?0.:1.;
        return r;
    }

    float rcros(in vec2 p){
        p-=vec2(.5);
        p*=rotate2d(PI/4.);
        p+=vec2(.5);
        return cros(p);
    }

    float box(in vec2 p){
        p-=vec2(.5);
        return (abs(p.x)<.3)&&(abs(p.y)<.3)?0.:1.;
    }

    float ibox(in vec2 p){
        return 1.-box(p);
    }

    vec2 movep(in vec2 p,in float r){
        float t=cos(mod(time,PI));
        vec2 ep=p+(r<.5?vec2(t,0.):vec2(0.,t));
        return fract(ep);
    }

    void main(void){
        vec2 p = (gl_FragCoord.xy) / min(resolution.x, resolution.y);
        di dis=devision(p);
        p=dis.p;
        vec2 ind=dis.i;

        
        float d=1.,r;
        r=rand(ind*.11);

        p=movep(p,r);

        if(r<.2){
            d=circle(p);
        }else if(r<.4){
            d=cros(p);
        }else if(r<.6){
            d=rcros(p);
        }else if(r<.8){
            d=box(p);
        }else{
            d=ibox(p);
        }
        
        vec3 color=vec3(d);

        
        gl_FragColor =vec4(color,1.0);
    }
    </script><!-- /fragment shader -->

    <!-- vertex shader -->
    <script id="vs" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec2 textureCoord;
    varying vec2 tCoord;
    
    void main(void){
        tCoord=textureCoord;
        gl_Position = vec4(position, 1.0);
    }
    </script><!-- /vertex shader -->

    <script src="script.js" type="text/javascript"></script>
    <style type="text/css">
        * {
            text-align: center;
            margin: 10px auto;
            padding: 0px;
        }

        canvas {
            box-shadow: 0px 0px 0px 1px gray;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <p style="display:none;"><input type="checkbox" id="check" checked><label for="check"> auto run</label></p>
    <p><button onclick="recode_start();">CreateVideo</button></p>
    <p><a href="#" id="downloadlink" style="display:none;">DownLoad</a></p>
</body>

</html>