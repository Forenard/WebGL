<html>

<head>
    <style type="text/css">
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        html {
            display: table;
            background-color: black;
        }

        body {
            display: table-cell;
            text-align: center;
            vertical-align: middle;
            color: white;
        }
    </style><!-- fragment shader -->
    <script id="fs" type="x-shader/x-fragment">precision mediump float;
    precision highp float;
    uniform sampler2D texture;
    uniform float time;
    uniform vec2  mouse;
    uniform vec2  resolution;
    varying vec2 tCoord;
    
    float rand(vec2 n) {
        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
    }
    
    float noise(vec2 p) {
        vec2 ip = floor(p);
        vec2 u = fract(p);
        u = u*u*(3.0-2.0*u);
    
        float res = mix(
            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
        return res*res;
    }
    
    const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);
    
    float fbm( in vec2 p ){
        float f = 0.0;
        f += 0.5000*noise( p ); p = m2*p*2.02;
        f += 0.2500*noise( p ); p = m2*p*2.03;
        f += 0.1250*noise( p ); p = m2*p*2.01;
        f += 0.0625*noise( p );
    
        return f/0.769;
    }
    
    float dwarp( in vec2 p ,float t) {
      vec2 q = vec2(fbm(p + vec2(0.0,0.0)))-t*0.15;
      vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2)));
      r+= t * 0.15;
      return clamp(fbm( p + 1.760*r ),0.0,1.0);
    }

    vec4 texColor(vec2 s){
        vec2 inv=(s+vec2(1.0))/2.0;
        inv.y=1.0-inv.y;
        return texture2D(texture,inv);
    }

    vec2 disp(vec2 p){
        vec2 res=vec2(-p.y,p.x);
        res*=dot(p,p)*2.0;
        return res;
    }
    vec3 hsb( in vec3 c ){
        vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                                 6.0)-3.0)-1.0,
                         0.0,
                         1.0 );
        rgb = rgb*rgb*(3.0-2.0*rgb);
        return c.z * mix(vec3(1.0), rgb, c.y);
    }

    void main(void){
        vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);
        float t=2.0*time+sin(2.0*time);
        float d=dwarp(p*2.0,t);
        d=floor(d*10.)/10.;
        //p=disp(p)*d+p;
        //p=clamp(p,-1.0,1.0);
        //gl_FragColor =texColor(p);
        float h=pow(d,.3);
        float s=pow(d,.6);
        float v=pow(d,.0);
        vec3 color=hsb(vec3(h,s,v));
        //bool ke=!(d>.5 || distance(vec2(p.x,0.8*p.y),vec2(1.9,2.))<3.);
        bool ke=d<.4;
        //gl_FragColor = ke?vec4(color,1.):vec4(1.)*.7;
        color=ke?color:hsb(vec3(.6,.4,p.y));
        color=distance(p,vec2(.0,.5))<.35?1.-color:color;
        gl_FragColor =vec4(color,1.);
    }
    </script><!-- /fragment shader -->

    <!-- vertex shader -->
    <script id="vs" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec2 textureCoord;
    varying vec2 tCoord;
    
    void main(void){
        tCoord=textureCoord;
        gl_Position = vec4(position, 1.0);
    }
    </script><!-- /vertex shader -->

    <script src="script.js" type="text/javascript"></script>
    <style type="text/css">
        * {
            text-align: center;
            margin: 10px auto;
            padding: 0px;
        }

        canvas {
            box-shadow: 0px 0px 0px 1px gray;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <p><input type="checkbox" id="check" checked><label for="check"> auto run</label></p>
    <p><button onclick="recode_start();">動画を作成する</button></p>
    <p><a href="#" id="downloadlink" style="display:none;">ダウンロード</a></p>
</body>

</html>